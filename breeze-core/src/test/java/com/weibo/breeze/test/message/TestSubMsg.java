/*
 * Generated by breeze-generator (https://github.com/weibreeze/breeze-generator)
 * Schema: testmsg.breeze
 * Date: 2019/6/18
 */
package com.weibo.breeze.test.message;

import com.weibo.breeze.*;
import com.weibo.breeze.message.Message;
import com.weibo.breeze.message.Schema;
import com.weibo.breeze.type.BreezeType;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static com.weibo.breeze.Breeze.getBreezeType;
import static com.weibo.breeze.type.Types.*;

public class TestSubMsg implements Message {
    private static final Schema schema = new Schema();
    private static BreezeType<Map<String, byte[]>> myMap1BreezeType;
    private static BreezeType<Map<Integer, List<Integer>>> myMap2BreezeType;
    private static BreezeType<List<Integer>> myArrayBreezeType;

    static {
        try {
            schema.setName("motan.TestSubMsg")
                    .putField(new Schema.Field(1, "myString", "string"))
                    .putField(new Schema.Field(2, "myInt", "int32"))
                    .putField(new Schema.Field(3, "myInt64", "int64"))
                    .putField(new Schema.Field(4, "myFloat32", "float32"))
                    .putField(new Schema.Field(5, "myFloat64", "float64"))
                    .putField(new Schema.Field(6, "myByte", "byte"))
                    .putField(new Schema.Field(7, "myBytes", "bytes"))
                    .putField(new Schema.Field(8, "myMap1", "map<string, bytes>"))
                    .putField(new Schema.Field(9, "myMap2", "map<int32, array<int32>>"))
                    .putField(new Schema.Field(10, "myArray", "array<int32>"))
                    .putField(new Schema.Field(11, "myBool", "bool"));
            myMap1BreezeType = getBreezeType(TestSubMsg.class, "myMap1");
            myMap2BreezeType = getBreezeType(TestSubMsg.class, "myMap2");
            myArrayBreezeType = getBreezeType(TestSubMsg.class, "myArray");
        } catch (BreezeException ignore) {
        }
        Breeze.putMessageInstance(schema.getName(), new TestSubMsg());
    }

    private String myString;
    private int myInt;
    private long myInt64;
    private float myFloat32;
    private double myFloat64;
    private byte myByte;
    private byte[] myBytes;
    private Map<String, byte[]> myMap1;
    private Map<Integer, List<Integer>> myMap2;
    private List<Integer> myArray;
    private boolean myBool;

    @Override
    public void writeToBuf(BreezeBuffer buffer) throws BreezeException {
        BreezeWriter.writeMessage(buffer, () -> {
            TYPE_STRING.writeMessageField(buffer, 1, myString);
            TYPE_INT32.writeMessageField(buffer, 2, myInt);
            TYPE_INT64.writeMessageField(buffer, 3, myInt64);
            TYPE_FLOAT32.writeMessageField(buffer, 4, myFloat32);
            TYPE_FLOAT64.writeMessageField(buffer, 5, myFloat64);
            TYPE_BYTE.writeMessageField(buffer, 6, myByte);
            TYPE_BYTE_ARRAY.writeMessageField(buffer, 7, myBytes);
            myMap1BreezeType.writeMessageField(buffer, 8, myMap1);
            myMap2BreezeType.writeMessageField(buffer, 9, myMap2);
            myArrayBreezeType.writeMessageField(buffer, 10, myArray);
            TYPE_BOOL.writeMessageField(buffer, 11, myBool);
        });
    }

    @Override
    public Message readFromBuf(BreezeBuffer buffer) throws BreezeException {
        BreezeReader.readMessage(buffer, (int index) -> {
            switch (index) {
                case 1:
                    myString = TYPE_STRING.read(buffer);
                    break;
                case 2:
                    myInt = TYPE_INT32.read(buffer);
                    break;
                case 3:
                    myInt64 = TYPE_INT64.read(buffer);
                    break;
                case 4:
                    myFloat32 = TYPE_FLOAT32.read(buffer);
                    break;
                case 5:
                    myFloat64 = TYPE_FLOAT64.read(buffer);
                    break;
                case 6:
                    myByte = TYPE_BYTE.read(buffer);
                    break;
                case 7:
                    myBytes = TYPE_BYTE_ARRAY.read(buffer);
                    break;
                case 8:
                    myMap1 = myMap1BreezeType.read(buffer);
                    break;
                case 9:
                    myMap2 = myMap2BreezeType.read(buffer);
                    break;
                case 10:
                    myArray = myArrayBreezeType.read(buffer);
                    break;
                case 11:
                    myBool = TYPE_BOOL.read(buffer);
                    break;
                default: //skip unknown field
                    BreezeReader.readObject(buffer, Object.class);
            }
        });
        return this;
    }

    @Override
    public String messageName() {
        return schema.getName();
    }

    @Override
    public String messageAlias() {
        return schema.getAlias();
    }

    @Override
    public Schema schema() {
        return schema;
    }

    @Override
    public Message defaultInstance() {
        return new TestSubMsg();
    }

    public String getMyString() {
        return myString;
    }

    public void setMyString(String myString) {
        this.myString = myString;
    }

    public int getMyInt() {
        return myInt;
    }

    public void setMyInt(int myInt) {
        this.myInt = myInt;
    }

    public long getMyInt64() {
        return myInt64;
    }

    public void setMyInt64(long myInt64) {
        this.myInt64 = myInt64;
    }

    public float getMyFloat32() {
        return myFloat32;
    }

    public void setMyFloat32(float myFloat32) {
        this.myFloat32 = myFloat32;
    }

    public double getMyFloat64() {
        return myFloat64;
    }

    public void setMyFloat64(double myFloat64) {
        this.myFloat64 = myFloat64;
    }

    public byte getMyByte() {
        return myByte;
    }

    public void setMyByte(byte myByte) {
        this.myByte = myByte;
    }

    public byte[] getMyBytes() {
        return myBytes;
    }

    public void setMyBytes(byte[] myBytes) {
        this.myBytes = myBytes;
    }

    public Map<String, byte[]> getMyMap1() {
        return myMap1;
    }

    public void setMyMap1(Map<String, byte[]> myMap1) {
        this.myMap1 = myMap1;
    }

    public Map<Integer, List<Integer>> getMyMap2() {
        return myMap2;
    }

    public void setMyMap2(Map<Integer, List<Integer>> myMap2) {
        this.myMap2 = myMap2;
    }

    public List<Integer> getMyArray() {
        return myArray;
    }

    public void setMyArray(List<Integer> myArray) {
        this.myArray = myArray;
    }

    public boolean getMyBool() {
        return myBool;
    }

    public void setMyBool(boolean myBool) {
        this.myBool = myBool;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        TestSubMsg that = (TestSubMsg) o;

        if (myInt != that.myInt) return false;
        if (myInt64 != that.myInt64) return false;
        if (Float.compare(that.myFloat32, myFloat32) != 0) return false;
        if (Double.compare(that.myFloat64, myFloat64) != 0) return false;
        if (myByte != that.myByte) return false;
        if (myBool != that.myBool) return false;
        if (myString != null ? !myString.equals(that.myString) : that.myString != null) return false;
        if (!Arrays.equals(myBytes, that.myBytes)) return false;
//        if (myMap1 != null ? !myMap1.equals(that.myMap1) : that.myMap1 != null) return false;
        if (myMap2 != null ? !myMap2.equals(that.myMap2) : that.myMap2 != null) return false;
        return myArray != null ? myArray.equals(that.myArray) : that.myArray == null;
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        result = myString != null ? myString.hashCode() : 0;
        result = 31 * result + myInt;
        result = 31 * result + (int) (myInt64 ^ (myInt64 >>> 32));
        result = 31 * result + (myFloat32 != +0.0f ? Float.floatToIntBits(myFloat32) : 0);
        temp = Double.doubleToLongBits(myFloat64);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (int) myByte;
        result = 31 * result + Arrays.hashCode(myBytes);
//        result = 31 * result + (myMap1 != null ? myMap1.hashCode() : 0);
        result = 31 * result + (myMap2 != null ? myMap2.hashCode() : 0);
        result = 31 * result + (myArray != null ? myArray.hashCode() : 0);
        result = 31 * result + (myBool ? 1 : 0);
        return result;
    }
}
